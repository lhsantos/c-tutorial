{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About this tutorial","text":"<p>This is a simple guide to learn computer programming, using the C language.</p> <ul> <li>If you are an absolute beginner to programming, start with About programming</li> <li>If you already have experience with other programming languages, but is a beginner at programming with C, start with About the C Language</li> <li>If you are already familiar with the C language and just wants to review specific topics, click on the relevant section in the menu to the left.</li> </ul>"},{"location":"introduction/about-programming/","title":"About programming","text":""},{"location":"introduction/about-programming/#what-is-a-programming-language","title":"What is a programming language?","text":"<p>A computer cannot directly execute commands in natural languages, such as English or Spanish. In fact, inside the computer's memory and processor (CPU), all instructions are represented as sequences of bits, i.e., values that can be either 0 or 1 (or, electrically, low voltage vs high voltage). This representation is called the binary code or machine code and is very specific for each type of processor family.</p> <p>Tip</p> <p>The instructions \"understood\" by the CPU describe very simple tasks, such as read value A from memory location X and add values B and C and store the result in A. A computer program combines sequences of these very simple instructions to finally perform complex tasks.</p> <p>Although it is possible write instructions to the computer directly in machine code, this task would be extremelly difficult and error prone, and unattainable for people who value their own sanity. Instead, we use programming languages to describe commands using a grammar that is similar to a natural languages (but not as flexible):</p> <ul> <li>first, we must create a plain text file, called the source code, containing a program written following the grammar and conventions of a specific programming language that we choose (there are many!);</li> <li>then, we use a special computer program (already in binary form), called a translator, that reads the source file as input, and converts it into machine code that can be directly executed by the CPU (Fig. 1).</li> </ul> Fig. 1 - Source code to binary code translation. <p>Since the translator itself is a computer program and not a human:</p> <ul> <li>it cannot guess what we mean if we make syntax errors (grammar mistakes) \u2014 thus, we must respect the language rules very strictly;</li> <li>it simply converts the code that we wrote, being unable to guess our intentions  \u2014 thus, if we make logical errors in our program, there's nothing the translator can do for us;</li> </ul> <p>Note</p> <p>Because programming languages, unlike natural languages, are very precise and unambiguous (there is only one possible interpretation for each command), they are a type of formal language. Other examples of formal languages include Mathematics notation and Propositional Logic.</p>"},{"location":"introduction/about-programming/#types-of-translators","title":"Types of translators","text":"<p>There are two main types of translators:</p> <ul> <li>interpreters are programs that execute source code on the fly, i.e, every time you run the interpreter, the source code is processed from scratch and each line is validated and executed according to the rules of the language, one by one (Fig. 2-a);</li> <li>compilers are programs that convert source code to an executable form, i.e., they read the source code once and generate a new file that contains binary instructions in a format that can be loaded by the operating sytem, this file is called an executable file (Fig. 2-b STEP 1); in order to run the program, the operating system loads the executable file into memory, and the CPU executes the binary code directly  (Fig. 2-b STEP 2) \u2014 at this point, the compiler is no longer necessary;</li> </ul>    Fig. 2 - (a) interpreters process and execute source code directly; (b) compilers generate an optimized binary format that can be efficiently executed by the CPU.    <p>But why use different strategies? Like most things in Computer Science, the choice is a trade-off:</p> <ul> <li>Since interpreters directly process the source code, it is simple to change the program and immediately test it, or to describe complex operations using simple commands; however, interpreting the source code line by line is usually many orders of magnitude slower than executing binary code;</li> <li>Since compilers generate binary instructions that are optimized to be run by the CPU, compiled programs are very fast and efficient; however, every time the source code changes, a new compilation is necessary, which can be a slow process for large and/or complex programs;</li> </ul> <p>Language implementers choose the best strategy based on the characteristics and goals of the language. Typically, languages with easier to use grammar and/or simple instructions that perform very complex operations are interpreted, while languages that have more detailed instructions and allow the programmer to control more aspects of the program execution are compiled.</p> <p>Table 1 below illustrates the main advantages and disadvantages of each strategy:</p> Criteria Interpreted languages Compiled languages Execution speed <p>\u2716 (Very) Slow</p> <p>\u21d2 The source code must be processed from scratch line by line, every time.</p> <p>\u2714 Fast</p> <p>\u21d2 After compiling the code once (which can be slow), the executable file is in the optimized binary format accepted by the CPU.</p> Dynamic behaviour(changing aspects of the program while executing) <p>\u2714 Simple</p> <p>\u21d2 Since the state of the program is created dynamically as the code is interpreted line by line, it is also simpler to dynamically change it.</p> <p>\u2716 Difficult</p> <p>\u21d2 Since the state of the program is represented as a memory layout during compilation, any dynamic behaviour must be designed beforehand by the programmer.</p> Expressivity(ability to express complex operations using simple instructions) <p>\u2714 High(er)</p> <p>\u21d2 Complex operations may be implemented internallly in the interpreter; which then translates simple commands into many instructions on the fly.</p> <p>\u2716 Low(er)</p> <p>\u21d2 Compiled languages can only be fast if they have commands closer to the machine instructions; for this reason, expressing complex operations usually requires many programming language commands.</p> Portability(run the program in many different platforms) <p>\u2714 Simple</p> <p>\u21d2 Since the source code is always processed directly, to support the language in a new environment (e.g., another processor architecture and/or operating system), it is enough to create an interpreter that runs in the target environment.</p> <p>\u2716 Difficult</p> <p>\u21d2 Since it is necessary to generate machine code that is compatible with the new environment, the new compiler must handle all the specific machine instructions, conventions and behaviour of the new environment, which is a much more complex task.</p> Optimization(taking advantage of specific aspects of the environment to make the program faster) <p>\u2716 Difficult</p> <p>\u21d2 Since the source code is read directly line by line, the execution of the program is necessarily slower, at least on the first run; however, modern interpreters often use techniques that generate optimized machine code on the fly to speed up the subsequent executions of different parts of the program (this process is very complex, though).</p> <p>\u2714 Simple(r)</p> <p>\u21d2 Since the compiler generates executable files with the machine instructions that will be directly executed by the CPU, it can greatly take advantage of the fastest execution strategies available for each processor and/or operating system.</p> Table 1: Interpreted vs compiled languages. <p>Warning</p> <p>The table above is a generalization. Recent technological advances in both strategies have greatly reduced their shortcomings, as briefly explained in \"Other strategies\" below.</p> <p>Tip</p> <p>A given programming language is not necessarily interpreted or compiled. The programming language itself is just a specification of a formal and precise way to write computer programs. There can be many implementations of the same language, and each of them could theoretically be either in the form of an interpreter or of a compiler. However, most languages are typically implemented using only one of these techniques.</p> <ul> <li>Examples of (typically) interpreted programming languages include: <code>JavaScript</code>, <code>PHP</code>, <code>Ruby</code>, <code>Python</code>, <code>Prolog</code>, etc...</li> <li>Examples of (typically) compiled programming languages include: <code>C</code>, <code>C++</code>, <code>Fortran</code>, <code>Rust</code>, <code>Pascal</code>, <code>Zig</code>, etc...</li> </ul> Other strategies [extra] <p>Besides \"pure\" compilers and interpreters \u2014 i.e, compilers that generate machine code or interpreters that read the source code as-is\u2014, there are other \"hybrid\" strategies that can be used to compensate the shortcomings of each approach. Some common examples:</p> <ul> <li>Intermediate representation: in this approach, the compiler does not generate machine code directly, but instead uses an intermediate binary code that is much easier and faster to execute and/or convert to machine code on the fly. The intermediate code is designed to be more easily portable to other environments, i.e, it is simpler to write a program that interprets the intermediate code, than to write a new compiler for every new system that must be supported. Examples of programming languages that use this approach are:<ul> <li><code>Java</code>, whose compiler generates <code>bytecode</code> to be processed by the <code>Java Virtual Machine</code>;</li> <li><code>C#</code>, whose compiler generates code in the <code>Common Intermediate Language</code> of the <code>.NET</code> platform;</li> <li><code>Python</code>, whose interpreter generates a <code>bytecode</code> representation of each source file when it is first read, and later uses this optimized version to speed up execution;</li> </ul> </li> <li>Just in Time Compilation: also known by the acronym \"JIT\", this technique used in many programming language (and intermediate code) interpreters consists of generating an optimized machine code representation of small parts of the program the first time that the part is processed; later executions of that part of the program are not processed again, but instead use the previously generated optimized version, making the overall execution much faster in most scenarios;</li> <li>Transpiling: a transpiler (or source to source translator) is a program that processes code written in a given source programming language and generates code in a different target programming language. Since it is usually easier to generate code in some existing programming language (instead of machine code or bytecode), this technique is useful when we want to test a new programming language idea without writing a complete new compiler, but instead using some existing compiler for a different language, and/or we want to make sure that our programs are compatible with programs written in the pre-existing language. Examples of programming languages that use transpilers are:<ul> <li><code>TypeScript</code>, whose compiler generates <code>JavaScript</code> code;</li> <li>the original <code>C++</code> compiler (<code>cfront</code>), generated <code>C</code> code (current <code>C++</code> compilers generate machine code directly);</li> <li><code>C++ Syntax 2</code>, whose <code>cppfront</code> compiler generates <code>C++</code> code;</li> <li><code>Nim</code>, whose compiler generates <code>C</code> code;</li> <li><code>Dart</code>, whose compiler can generate <code>JavaScript</code></li> </ul> </li> </ul> Domain-specific languages [extra] <p>A domain-specific language, often referred to by the acronym DSL is a special type of formal language, ofen containing some features found in programming languages, that is used in very restricted contexts, as opposed to general purpose programming languages that can be used in a many different of contexts. They are tipically used to describe and/or manipulate specific types of data or control specific systems. It is easier to understand with examples:</p> <ul> <li>The <code>Structured Query Language</code> (<code>SQL</code>), is a language used to manipulate and retrieve data from certain types of databases, allowing users to perform complex logic operations and groupings in the data, among other features;</li> <li>The <code>HyperText Markup Language</code> (<code>HTML</code>), is used to describe the layout and contents of web pages;</li> <li>The <code>JavaScript Object Notation</code> (<code>JSON</code>), is used to describe data in a portable format that can be easily and quickly processed by many different systems (originally, JavaScript);</li> <li>The <code>bison</code> syntax, is the notation used to describe programming language grammars and generate syntatic analyzers using the program <code>bison</code>;</li> </ul> <p>DSL are usually interpreted, and their processing happens inside some bigger context, such as within a database management system or a web browser.</p>"},{"location":"introduction/about-programming/#abstraction-levels","title":"Abstraction levels","text":"<p>The main reason why there are so many programming languages available is that each language is designed with a certain purpose in mind. Although most languages are general purpose \u2014 which means that they can be used to create applications in several diffent contexts \u2014, the design choices made for each language reflect the type of applications for which they should ideally be used.</p> <p>That said, one of the main characteristics that define a language is its level of abstraction. Although a blurry notion, generally speaking, the level of abstration defines if the commands available in the language are closer to machine code, in other words, they have a low level of abstration, or if they are closer to natural (human) language, in other words, they have a high level of abstration.</p> <p>Table 2 below illustrates this concept by giving examples of languages in different levels of abstration and what kind of commands they typically provide:</p> Level Language Type of commands HIGH LOW SQL <ul> <li>\"Get a user by name\"</li> <li>\"Count comments of a given post\"</li> </ul> Java <ul> <li>\"Define a type called <code>Player</code>, which is a subtype of <code>GameEntity</code>\"</li> <li>\"Create a list of objects of type <code>Monster</code>\"</li> <li>\"Create a variable that holds text\"</li> <li>\"Set the name of the monster\"</li> C <ul> <li>\"Create a memory location that holds a sequence of characters\"</li> <li>\"Given a sequence of integers, get element at position <code>5</code>\"</li> <li>\"Do:              <ul> <li>Make <code>index</code> be <code>0</code>;</li> <li>while <code>index</code> is less than the length of the sequence:</li> <ul> <li>show the element at position <code>index</code>;                   <li>increment <code>index</code>;\"</li> </li> </ul> Assembly Language(a textual representation of machine code) <ul> <li>\"load a 4-byte integer value from memory address <code>0xFFFFA</code> into register <code>R1</code>;\"</li> <li>\"add integer value at register <code>R2</code> to register <code>R7</code> and put the result in register <code>R1</code>;\"</li> <li>\"jump to address <code>0xABABAB</code>;\"</li> </ul> Binary code(machine code) The same as Assembly Language, but with each parameter encoded in binary form (sequences of <code>0</code> and <code>1</code>) Table 2: Examples of different levels of abstraction. <p>Tip</p> <p>Although \"low level\" languages such as C or C++ are based on very detailed commands (i.e., that allow to control the hardware very precisely), we will see during this tutorial that they also provide are mechanisms that allow programmers to group sequences of instructions into single blocks with a name, called <code>functions</code> (or <code>procedures</code>), or to define their own custom <code>data types</code> that can be manipulated more conveniently. Using such mechanisms, new levels of abstraction can be created within the source code to allow expressing more complex operations. This process is the most fundamental aspect of writing good programs.</p>"}]}